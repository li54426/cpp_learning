![](https://csdnimg.cn/release/blogv2/dist/pc/img/original.png)

[Zjkai\_](https://blog.csdn.net/u014711890) ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png) 于 2022-03-12 12:38:03 发布 ![](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png) 9296

版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。



| 结合率和运算符 | 功能 | 用法 |
| -------------- | ---- | ---- |
| ::             |      |      |
| .     成员选择 |      |      |
| ->  成员选择   |      |      |
| []             |      |      |
| ()             |      |      |
|                |      |      |





## 1、[Lambda](https://so.csdn.net/so/search?q=Lambda&spm=1001.2101.3001.7020)表达式的概述

C++11引入了Lambda[表达式](https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020)，用于定义并创建匿名的函数对象，主要用于方便编程，避免全局变量的定义，并且变量安全。

Lambda表达式的定义语法如下：

```
[函数对象参数](函数参数)修饰符->返回值类型{函数体};
```

## 2、Lambda表达式语法分析

## 2.1 函数对象参数

\[\]标识一个Lambda表达式的开始，这一部分是不可以忽略的。函数对象参数只能使用到定义该Lambda表达式为止定义过的局部变量，包括Lambda表达式所在类的成员变量。函数参数有以下几种形式：

-   空：代表不捕获Lambda表达式外的变量；
-   &：代表以引用传递的方式捕获Lambda表达式外的变量；
-   \=：代表以值传递的方式捕获Lambda表达式外的变量，即以const引用的方式传值；
-   this：表示Lambda表达式可以使用Lambda表达式所在类的成员变量；
-   a或=a：表示以值引用的方式传递变量 a a a，即const int a,在函数体内不可改变a的值；但是可以对Lambda表达式使用mutable修饰符修饰，使得函数对象参数可以进行赋值，但是该函数对象参数不是被修改为引用传递方式，下面进行细说；
-   &a：表示以引用传递的方式传递变量 a a a，在函数体内可以改变a的值；
-   x，&y：x为值传递方式，y为引用传值方式；
-   \=，&x，&y：除x，y为引用传递方式以外，其他参数都为值传递方式进行传递；
-   &，x，y：除x，y为值传递方式以外，其他参数都为引用传递方式进行传递；

## 2.2 函数参数

这一部分可以被省略（如果函数无参数），我们可以使用下面方式定义Lambda表达式

```
auto f = [] {
cout << "Hello" << '\n';
};
```

也可以使用下面的方式定义Lambda表达式

```
auto f = [] (string s) {
cout << "Hello " << s << '\n';
};
```

## 2.3 修饰符

这一部分是可以省略的，常见的修饰符有两个，一个是mutable，另一个是exception

-   mutable：当函数参数以值引用传递方式传递时，在函数体内是不可以修改该函数参数的值的，我们可以使用mutable修饰符，使得该函数参数可以**在函数体内改变**，下面我们实验一下

```
int x = 1;
auto test = [x] () { x++; };
test();
```

这样会报错，参数x是值传递的方式，是一个只读变量，但是我们加入mutable后，就不会报错

```
int x = 1;
auto test = [x] () mutable { x++; cout << x << ' '; };
test();cout << x << '\n';
```

这样我们就过了编译，不妨猜猜输出结果，是2 2还是2 1呢？

答案是2 1，注意上边加黑的字体：被mutable修饰的函数参数，该函数参数可以**在函数体内改变**，也就是说不会改变函数体外该变量的值，我们也可以理解为在函数体内拷贝了这个变量的同名变量。

-   exception：exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。

## 2.4 返回值类型

这一部分也是可以省略的，Lambda表达式会自动推断返回值类型，但是返回类型不统一会报错；

## 2.5 函数体

标识函数的实现，这一部分可以为空，但是不能省略。